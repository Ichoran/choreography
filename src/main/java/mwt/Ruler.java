/* Ruler.java - Generates and renders a graduated set of lines.
 * Copyright 2010 Howard Hughes Medical Institute and Nicholas Andrew Swierczek
 * Also copyright 2015 Calico Life Sciences LLC (authored by Rex Kerr)
 * This file is a part of Choreography and is distributed under the
 * terms of the GNU Lesser General Public Licence version 2.1 (LGPL 2.1).
 * For details, see http://www.gnu.org/licences
 */

package mwt;

import java.text.*;
import javax.swing.*;
import java.awt.*;

import mwt.numerics.*;
  
/**
 * A class which extends a JPanel and automatically generates and draws a graduated set of lines 
 * with an appropriate interval to represent a distance, in data map coordinates, between two vectors.
 * @author Nicholas A. Swierczek (swierczekn at janelia dot hhmi dot org)
 */
public class Ruler extends JPanel
    {
    /**
     * Constant type-checking flag for horizontal orientations of any Ruler.
     */
    public static boolean HORIZONTAL = true;

    /**
     * Constant type-checking flag for horizontal orientations of any Ruler.
     */
    public static boolean VERTICAL = false;

    /**
     * boolean flag representing the orientation of this Ruler
     */
    private boolean orientation;

    /**
     * Number formatting object for preparing values for display.
     */
    private DecimalFormat df = new DecimalFormat("0.##");

    /**
     * integer storing the width of each character in the Font {@code font} used to display numbers.
     */
    private int font_width = -1;

    /**
     * integer storing the height of each character in the Font {@code font} used to display numbers.
     */
    private int font_height = -1;

    /**
     * Dimension storing the screen dimensions of just the portion of this Ruler that will contain
     * the graduated ticks.
     */
    private Dimension ruler_dim = new Dimension(0,0);

    /**
     * Dimension storing the screen dimensions of the JPanel containing this Ruler.
     */
    private Dimension panel_dim = new Dimension(0,0);

    /**
     * Dimension storing the values of {@code ruler_dim} plus an appropriate buffer 
     * (currently 50 pixels for horizontal rulers and 0 for vertical ones). This is used
     * to cause rulers to display properly within the GUI.
     */
    private Dimension this_dim;

    /**
     * DataView represented by this Ruler.
     */
    public DataView view;
    
    /**
     * Monospaced font used for displaying values associated with ticks.
     */
    private Font font;

    /**
     * A state variable that becomes true when it becomes safe to attempt to draw this Ruler, which is
     * when a {@code near} and {@code far} vector have been set and the difference between them
     * is greater than 0.0.
     */
    private boolean displayable = true;

    /**
     * Constructor for a Ruler of 
     * @param or Orientation flag, which refers to the above defined public static variables {@code HORIZONTAL} and {@code VERTICAL}.
     * @param dim Dimension of the panel that encloses this Ruler.
     * @param n Vector representation of upper left corner of data space.
     * @param sz Vector representation of thi size of the view in data space.
     * @throws IllegalArgumentException if null is passed for {@code dim}.
     */
    public Ruler(boolean or,Dimension dim, double x, double y, double width, double height, int decimal_places ) {		        
        super();        
        if( dim == null ) throw new IllegalArgumentException("argument dim cannot be null");
        view = new DataView(x,y,width,height);

        orientation = or;
        
        setDimension(dim);
        
        font = new Font("monospaced",Font.PLAIN,10);

        if( decimal_places > 0 ) {
            StringBuffer buf = new StringBuffer("0.");
            for( int i = 0; i < decimal_places; i++ ) {
                buf.append("#");
            }
            df = new DecimalFormat(buf.toString());
        }
    }
    
    public void setDimension( Dimension dim ) {
        panel_dim = dim;
        /*
         * NOTE: The hardcoded values are designed to make the Rulers display "nicely."
         *              As this was an aesthetic choice, they are to some extent arbitrary.
         */
        if( orientation == HORIZONTAL ) {
            ruler_dim = new Dimension((int)panel_dim.getWidth(),35);
            this_dim = new Dimension((int)panel_dim.getWidth()+50,35);
        }
        else {		
            ruler_dim = new Dimension(50,(int)panel_dim.getHeight());
            this_dim = new Dimension(50,(int)panel_dim.getHeight());
        }		

        this.setPreferredSize(this_dim);
        this.setSize(this_dim);        
    }
       
    /**
     * Using the values previously generated by a successful call to {@code calculate()}, draws
     * the appropriate amount of tick marks, with values, on the specified Graphics object.
     * @param g Graphics object to draw this Ruler on.
     */
    public void drawInterval(Graphics2D g2d) {  
        if( displayable && view != null ) {            
            String val;
            int label_offset = 0;
            g2d.setFont(font);
            // If this function has never been called before, retrieve the font width and height, which do not
            // exist until now.
            if( font_width < 0 || font_height < 0 ) {
                font_width = g2d.getFontMetrics().stringWidth(" "); // NOTE: A monospaced font is stipulated.
                font_height = g2d.getFontMetrics().getHeight();
            }
            
            if( orientation == HORIZONTAL ) {			
                // TODO: Move this out of the drawing loop.
                double pixelSize = view.size().x/panel_dim.width;

                Vec2D zero = view.pos().opMinus(); // amount to subtract from view.pos to get data 0,0.
                zero.eqDivide(pixelSize); // same amount in pixels.
                
                for( double xx = zero.x ; xx < ruler_dim.width; xx += 50 ) {	
                    // NOTE: We want the label to be drawn such that tick is at the half-way point in the number.
                    val = df.format(xx * pixelSize + view.pos().x);
                    val = ( val.compareTo("-0") == 0 ) ? "0" : val;
                    label_offset = (val.length()/2)*font_width;
                    
                    g2d.drawString(val,(int)Math.round(xx)-label_offset,(int)ruler_dim.getHeight()-5);
                    g2d.drawLine((int)Math.round(xx),0,(int)Math.round(xx),20);                    
                } 
                for( double xx = zero.x - 50; xx > 0; xx -= 50) {
                    if( xx < ruler_dim.width ) {                        
                        val = df.format(xx * pixelSize + view.pos().x);
                        val = ( val.compareTo("-0") == 0 ) ? "0" : val;
                        label_offset = (val.length()/2)*font_width;

                        g2d.drawString(val,(int)Math.round(xx)-label_offset,(int)ruler_dim.getHeight()-5);
                        g2d.drawLine((int)Math.round(xx),0,(int)Math.round(xx),20);
                    }
                }
            }
            else {
                // TODO: Move this out of the drawing loop.
                double pixelSize = view.size().x/panel_dim.width;

                Vec2D zero = view.pos().opMinus(); // amount to subtract from view.pos to get data 0,0.
                zero.eqDivide(pixelSize); // same amount in pixels.
                               
                for( double y = zero.y ; y < ruler_dim.height; y += 50 ) {
                    val = df.format(y * pixelSize + view.pos().y);                   
                    val = ( val.compareTo("-0") == 0 ) ? "0" : val;

                    g2d.drawString(val,2,(int)Math.round(y)-2);                    
                    g2d.drawLine(0,(int)Math.round(y),(int)ruler_dim.getWidth()-5,(int)Math.round(y));
                } 
                for( double y = zero.y - 50; y > 0; y -= 50 ) {
                    
                    val = df.format(y * pixelSize + view.pos().y);                   
                    val = ( val.compareTo("-0") == 0 ) ? "0" : val;

                    g2d.drawString(val,2,(int)Math.round(y)-2);                    
                    g2d.drawLine(0,(int)Math.round(y),(int)ruler_dim.getWidth()-5,(int)Math.round(y));
                }                
            }
        }
    } // end public void drawInterval(Graphics g)
	
    /**
     * Draws the outline for this Ruler and causes the ticks to be drawn, if and only if it is safe to do so, as
     * defined by the {@code displayable} flag.
     * @param g Graphics object to draw this Ruler on.
     */
    @Override
    public void paintComponent(Graphics g) {
        super.paintComponent(g);
        if( view != null && view.valid() ) {
            Graphics2D g2d = (Graphics2D)g;
            if( orientation == HORIZONTAL ) {
                // Draw "northern" border line on Ruler.
                g2d.drawLine(0,0,(int)ruler_dim.getWidth(),0);
            }
            else {
                // Draw "western" border line on Ruler.
                g2d.drawLine(0,0,0,(int)ruler_dim.getHeight());
            }
            drawInterval(g2d);
        }
    }
}
